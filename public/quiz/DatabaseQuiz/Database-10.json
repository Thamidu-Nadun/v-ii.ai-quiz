{
    "questions": [
        {
            "question": "What is the primary goal of the logical database design step?",
            "option_a": "To gather user requirements through interviews.",
            "option_b": "To create an ER diagram based on business rules.",
            "option_c": "To convert the conceptual design into a schema for the chosen DBMS data model.",
            "option_d": "To install and configure the database server hardware.",
            "correct_answer": "option_c",
            "explanation": "Logical design is the step where the high-level, DBMS-independent conceptual model (like an ER diagram) is transformed into a logical schema (like relational tables) specific to a data model (e.g., the relational model)."
        },
        {
            "question": "In the relational model, the main construct representing data is called a:",
            "option_a": "Entity",
            "option_b": "Relationship",
            "option_c": "Relation",
            "option_d": "Tuple",
            "correct_answer": "option_c",
            "explanation": "The core building block of the relational model is the \"relation,\" which is commonly visualized as a table."
        },
        {
            "question": "A relational schema primarily describes:",
            "option_a": "The current set of rows in a table.",
            "option_b": "The name, columns (attributes), and their domains for a relation.",
            "option_c": "The relationships between different tables.",
            "option_d": "The SQL queries that will be run on the database.",
            "correct_answer": "option_b",
            "explanation": "A schema is the structure or blueprint of a relation. An instance is the current set of data (rows) that conforms to that schema."
        },
        {
            "question": "How is a regular, strong entity from an ER diagram typically mapped to the relational model?",
            "option_a": "Its attributes become a separate table, and its primary key is discarded.",
            "option_b": "It is not mapped; only relationships are mapped.",
            "option_c": "It becomes a table. The entity's attributes become the table's columns, and its primary key becomes the table's primary key.",
            "option_d": "Its attributes are added as columns to the table of a related entity.",
            "correct_answer": "option_c",
            "explanation": "This is the fundamental rule for mapping strong entities. Each strong entity becomes its own relation (table)."
        },
        {
            "question": "How is a 1:1 (one-to-one) relationship between two strong entities (E1 and E2) best mapped?",
            "option_a": "Create a new separate table for the relationship.",
            "option_b": "Add the primary key of E1 as a foreign key in the table for E2.",
            "option_c": "Add the primary key of E2 as a foreign key in the table for E1.",
            "option_d": "Either b or c, choosing the entity with total participation if it exists.",
            "correct_answer": "option_d",
            "explanation": "For a 1:1 relationship, the foreign key can be placed in either table. It is most efficient to place it in the table of the entity that has total participation in the relationship to avoid null values."
        },
        {
            "question": "How is a 1:N (one-to-many) relationship between two strong entities (Department and Employee) mapped?",
            "option_a": "Create a new separate table for the relationship.",
            "option_b": "Add the primary key of the \"1\" side (Department) as a foreign key in the table for the \"N\" side (Employee).",
            "option_c": "Add the primary key of the \"N\" side (Employee) as a foreign key in the table for the \"1\" side (Department).",
            "option_d": "Merge the two entity tables into a single table.",
            "correct_answer": "option_b",
            "explanation": "The standard mapping for a 1:N relationship is to place a foreign key on the \"many\" side of the relationship, referencing the \"one\" side."
        },
        {
            "question": "How is an M:N (many-to-many) relationship between two strong entities (Student and Course) mapped?",
            "option_a": "Add the primary key of Student as a foreign key in the Course table.",
            "option_b": "Add the primary key of Course as a foreign key in the Student table.",
            "option_c": "Create a new relation (table) whose primary key is a composite of the primary keys of the participating entities.",
            "option_d": "Ignore the relationship as it is not important.",
            "correct_answer": "option_c",
            "explanation": "An M:N relationship cannot be represented by adding foreign keys to the original tables. A new \"junction\" or \"relationship\" table must be created with foreign keys to both participating entities. Its primary key is often the combination of these foreign keys."
        },
        {
            "question": "How is a multi-valued attribute from an ER diagram mapped?",
            "option_a": "It is ignored and not mapped.",
            "option_b": "It is mapped to a column in the same table as the entity.",
            "option_c": "It is mapped to a separate new table, with the primary key of the original entity included as a foreign key.",
            "option_d": "It is converted into a single-valued attribute.",
            "correct_answer": "option_c",
            "explanation": "Since a single column in a relational table cannot hold multiple values, a multi-valued attribute must be decomposed into a new table linked back to the original entity by a foreign key."
        },
        {
            "question": "A weak entity is mapped to a relation. What is included in this relation's primary key?",
            "option_a": "Only its own partial key.",
            "option_b": "Only the primary key of its owner entity.",
            "option_c": "A composite key formed from its partial key and the primary key of its owner entity.",
            "option_d": "A new, surrogate key is created.",
            "correct_answer": "option_c",
            "explanation": "A weak entity is identified by its owner. Therefore, its primary key in the relational model is the combination (composite) of its own discriminator (partial key) and the primary key of the owner entity."
        },
        {
            "question": "Which ISA mapping option involves creating a separate relation for the superclass and for each subclass?",
            "option_a": "Option 1",
            "option_b": "Option 2",
            "option_c": "Option 3",
            "option_d": "Option 4",
            "correct_answer": "option_a",
            "explanation": "Option 1 creates a table for the superclass (e.g., Person) and a table for each subclass (e.g., Student, Faculty). The subclass tables have the superclass's PK as both their PK and a FK back to the superclass table."
        },
        {
            "question": "Option 1 for mapping ISA relationships is suitable for which of the following constraints?",
            "option_a": "Only for disjoint and total constraints.",
            "option_b": "Only for overlapping and partial constraints.",
            "option_c": "It works for all constraints (disjoint/overlapping, total/partial).",
            "option_d": "Only for total constraints.",
            "correct_answer": "option_c",
            "explanation": "A key advantage of Option 1 is its flexibility. It can handle all possible specialization constraints."
        },
        {
            "question": "Which ISA mapping option creates a single relation containing all attributes of the superclass and all subclasses?",
            "option_a": "Option 1",
            "option_b": "Option 2",
            "option_c": "Option 3",
            "option_d": "Option 4",
            "correct_answer": "e",
            "explanation": "Both Option 3 and Option 4 are \"single-relation\" options. They differ in how they handle the constraints (Option 3 uses a 'type' attribute for disjoint, Option 4 uses Boolean flags for overlapping)."
        },
        {
            "question": "Mapping Option 2 for ISA relationships requires that the specialization has which constraint?",
            "option_a": "It must be disjoint.",
            "option_b": "It must be overlapping.",
            "option_c": "It must be partial.",
            "option_d": "It must be total (covering).",
            "correct_answer": "option_d",
            "explanation": "Option 2 creates tables only for the subclasses. If the specialization is partial (not covering), an entity that is only in the superclass would have nowhere to be stored, losing information."
        },
        {
            "question": "In a single-table ISA mapping (Option 3 or 4), what is a significant disadvantage if the subclasses have many attributes?",
            "option_a": "It cannot represent disjoint constraints.",
            "option_b": "It cannot represent overlapping constraints.",
            "option_c": "It leads to many NULL values in the table.",
            "option_d": "The foreign key constraints become too complex.",
            "correct_answer": "option_c",
            "explanation": "If you put all attributes from all subclasses into one table, a tuple that belongs to only one subclass will have NULL values for all the attributes belonging to the other subclasses, wasting space."
        },
        {
            "question": "Which mapping option is best for an overlapping specialization where subclasses have very few attributes?",
            "option_a": "Option 1",
            "option_b": "Option 2",
            "option_c": "Option 3",
            "option_d": "Option 4",
            "correct_answer": "option_d",
            "explanation": "Option 4 (single table with Boolean flags) is well-suited for overlapping specializations. The few attributes minimize the problem of NULL values."
        },
        {
            "question": "A ternary relationship (between three entities) is mapped by:",
            "option_a": "Adding foreign keys to each of the three entity tables.",
            "option_b": "Creating a new relationship relation that includes the primary keys of all participating entities as foreign keys.",
            "option_c": "Ignoring one of the entities.",
            "option_d": "Combining two of the entities into one table first.",
            "correct_answer": "option_b",
            "explanation": "Similar to an M:N binary relationship, an n-ary relationship (involving more than two entities) requires a separate table whose primary key is typically a composite of the foreign keys pointing to the participating entities."
        },
        {
            "question": "What is the purpose of a foreign key in the relational model?",
            "option_a": "To uniquely identify a tuple within its own table.",
            "option_b": "To ensure that every attribute has a value.",
            "option_c": "To enforce referential integrity by linking a tuple to a tuple in another relation.",
            "option_d": "To create a backup of the primary key.",
            "correct_answer": "option_c",
            "explanation": "A foreign key in one table references the primary key in another table, ensuring that the value exists in the referenced table and maintaining the link between related data."
        },
        {
            "question": "When mapping a composite attribute, the typical approach is to:",
            "option_a": "Create a separate table for it.",
            "option_b": "Ignore the composite nature and map it as a simple attribute.",
            "option_c": "Create a column for the composite attribute and a column for each of its component attributes.",
            "option_d": "Create a column for each of its component attributes, but not for the composite attribute itself.",
            "correct_answer": "option_d",
            "explanation": "The relational model flattens composite attributes. The composite attribute (e.g., 'Name') is not created as a column; instead, its simple components (e.g., 'first_name', 'last_name') become columns."
        },
        {
            "question": "Consider an ER diagram with a relationship that has a descriptive attribute. How is this relationship mapped?",
            "option_a": "The descriptive attribute is added to the table of the entity on the \"one\" side.",
            "option_b": "The descriptive attribute is added to the table of the entity on the \"many\" side.",
            "option_c": "The descriptive attribute is added to the junction table created for the relationship.",
            "option_d": "The descriptive attribute is ignored as it cannot be mapped.",
            "correct_answer": "option_c",
            "explanation": "Whether it's an M:N relationship or an n-ary relationship with its own attributes, the descriptive attributes are included as columns in the separate relationship table that is created."
        },
        {
            "question": "The choice between different ISA mapping options is primarily a trade-off between:",
            "option_a": "Security and performance.",
            "option_b": "Data redundancy and query simplicity.",
            "option_c": "The number of NULL values and the number of joins required for queries.",
            "option_d": "The color of the database UI and the brand of the DBMS.",
            "correct_answer": "option_c",
            "explanation": "Single-table options (3 & 4) reduce joins (simpler queries) but can lead to many NULLs. Multi-table options (1 & 2) avoid NULLs but require joins to get complete information (more complex queries)."
        },
        {
            "question": "You are mapping an ER diagram for a hospital. The \"Patient\" entity has a multi-valued attribute \"allergy\". How is this represented in the relational schema?",
            "option_a": "A column named allergy in the Patient table.",
            "option_b": "A new table Patient_Allergy with columns patient_id (FK to Patient) and allergy.",
            "option_c": "Two columns in the Patient table: allergy1 and allergy2.",
            "option_d": "Ignore allergy as it is multi-valued.",
            "correct_answer": "option_b",
            "explanation": "Multi-valued attributes require a separate table to hold multiple values per entity instance."
        }
    ]
}